# 第一章	面向对象设计原则

1. 单一职责原则

   ​	一个对象应该只包含单一的职责,并且该职责被完整地封装再一个类中

2. 开闭原则

   软件实体应当对扩展开放,对修改关闭,实际上是指团建实体应尽量在不修改代码的情况下拓展

3. 里氏代换原则

   所有引用的基类的地方必须能透明地使用其他子类的对象,里氏原则表明在软件种将一个基类对象替换成它的子类对象,程序将不会产生任何错误和异常,反过来则不成立

4. 依赖倒转原则

   高层模块不应该依赖低层模块,它们都应该依赖抽象,抽象不应该依赖于细节,细节应该依赖于抽象,依赖倒转原则要求针对接口编程,不要针对实现编程

5. 接口隔离原则

   客户端不应该依赖那些它不需要的接口

6. 合成复用原则

   优先使用对象组合,而不是通过继承来达到复用的目的

7. 迪米特法则

   每个软件单位对其他单位都只有最少的知识,而且局限于那些与本单位密切相关的软件单位,要求一个软件实体应该尽可能少地与其他实体发生相互作用



# 第三章	简单工厂模式

## 3.1	概述

​	定义一个工厂类,它可以根据参数的不同返回不同类的实例,被创建的实例通常都具有共同的父类

​	由于简单工厂模式中用于创建实例的方法通常是静态(static)方法,因此简单工厂模式==静态工厂方法模式(Static Factory Method)

## 3.2	简单工厂模式的结构和实现

### 3.2.1	简单工厂模式结构

1. Factory(工厂角色) 即工厂类,负责实现创建所有产品的实例的内部逻辑,被外界调用,提供静态工厂方法,返回类型为产品类型
2. Product(抽象产品角色) 工厂类创建的所有对象的父类,封装了各种产品对象的公有方法,
3. ConcreteProduct(具体产品角色) 简单工厂模式的创建目标,所有被创建的对象都充当这个角色的具体类的实例



#### 结构图

### 3.2.2	简单工厂模式实现

```java
//抽象图表接口,充当抽象产品类
public interface Chart {

	public void display();

}
```

```java
//工厂类,
public class ChartFactory {

	//静态工厂方法
	public static Chart getChart(String type) {
		Chart chart = null;
		if(type.equalsIgnoreCase("histogram")) {
			chart  = new HistogramChart();
			System.out.println("初始化设置柱状图");
		}else if(type.equalsIgnoreCase("pie")) {
			chart  = new PieChart();
			System.out.println("初始化设置饼状图");
		}else if(type.equalsIgnoreCase("line")) {
			chart  = new LineChart();
			System.out.println("初始化设置折线图");
		}
		return chart;
	}

		
}
```

```java
public class HistogramChart implements Chart {

	
	
	public HistogramChart() {
		super();
		// TODO Auto-generated constructor stub
		System.out.println("创建柱状图");
	}

	@Override
	public void display() {
		// TODO Auto-generated method stub
		System.out.println("显示柱状图");
	}

}
```

```java
public class Client {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Chart chart;
		chart = ChartFactory.getChart("histogram");
		chart.display();
	}

}
```

### 3.2.3	简单工厂模式优缺点

​	优点:	

​		工厂类包含了必要的判断逻辑,客户端免除直接拆功能键产品对象的职责

​		客户端无须知道拆功能键的具体产品类的类名,只需要知道具体产品类对应的参数

​	缺点:

​		工厂类集中了所有产品的创建逻辑,职责过大一旦不能正常工作,整个系统都要受到影响

​		使用简单工厂类模式势必会增加系统中类的个数,增加了系统的复杂度和理解难度

​		一旦添加新的产品就需要修改工厂逻辑,在产品类型较多的时候有可能照成工厂逻辑过于复杂

​		使用静态工厂方法,造成工厂角色无法形成基于继承的等级结构



###  3.2.4	适用环境

1. 工厂类负责创建的对象比较少,由于创建的对象比较少,不会造成工厂方法的业务逻辑过于复杂
2. 客户端只知道传入工厂类的参数,对于如何创建对象并不关心



# 第四章	工厂方法模式

## 4.1	概述

工厂方法模式:定义一个用于创建对象的接口,但是让字类决定将那个类实例化,工厂方法模式让一个类的实例化延迟到其子类

## 4.2	工厂模式结构与实现

### 4.2.1	工厂方法模式结构

Product(抽象产品):它是定义产品的接口,是工厂方法模式所创建对象的超类型,也就是产品对象的公共父类

ConcreteProduct(具体产品):它实现了抽象产品接口,某种类型的具体产品由专门的具体工厂创建,具体工厂和具体产品之间一一对应

Factory(抽象工厂):在抽象工厂类中声明了工厂方法，用于返回一个产品．抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口

ConcreteFactory(具体工厂)：他是抽象工厂类的子类，实现了在抽象工厂中声明的工厂发发，并可由客户端调用，返回一个具体产品类的实例

### ４.２.２	工厂模式实现

```java
public interface LoggerFactory {
	public Logger createLogger();
}


public interface Logger {
	public void writeLog();
}


public class DatabaseLoggerFactory implements LoggerFactory {

	@Override
	public Logger createLogger() {
		// TODO Auto-generated method stub
		Logger logger = new DatabaseLogger();
		return logger;
	}

}

public class DatabaseLogger implements Logger {


	@Override
	public void writeLog() {
		// TODO Auto-generated method stub
		System.out.println("数据库日志记录");
	}

}

public class Client {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		LoggerFactory factory;
		Logger logger ;
		
		factory = new DatabaseLoggerFactory();
//		factory = new FileLoggerFactory();
		logger = factory.createLogger();
		logger.writeLog();
	}

}
```

### ４.２.３	工厂方法的隐藏

### ４.２.４	工厂模式优缺点

优点：提供了专门的工厂方法来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节；它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部；在系统中加入新产品时完全符合开闭原则，

缺点：系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销，增加了系统的抽象性和理解难度

### ４.２.５	适用环境

客户端不知道它所需要的对象的类；抽象工厂类通过子类来指定创建那个对象



# 第五章	抽象工厂模式

## 5.1	产品等级结构和产品族

![1572531639869](C:\Users\Crazy\AppData\Roaming\Typora\typora-user-images\1572531639869.png)

## 5.2	抽象工厂模式概述

抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式．抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构

抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类

## ５.３	抽象工厂模式结构与实现

### ５.３.１	抽象工厂模式结构

1. AbstractFactory(抽象工厂)：它声明了一组用于创建一族产品的方法，每个方法对应一种产品
2. ConcreteFactory(具体工厂)：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每个产品都位于某个产品等级结构中
3. AbstractProduct(抽象产品)：它为某种产品声明接口，在抽象产品中声明了产品所具有的业务方法
4. ConcreteProduct(具体产品): 它定义具体工厂生产的具体产品对象,实现抽象产品接口中声明的业务方法



### 5.3.2	抽象工厂模式实现



## 5.4	开闭原则的倾斜性

如果在设计之初因为考虑不全面,忘记了某种类型的功能,(少了单选按钮),那么在往系统中知难而进该单选按钮是将会非常麻烦,因为抽象工厂SkinFactory 中根本没有提供创建单选按钮的方法,如果需要增加单选按钮,首先需要修改抽象工厂方法SkinFactory然后逐个具体工厂类,增加响应的方法实现不同的皮肤库中创建单选按钮,还需要修改客户端

在抽象工厂模式中增加新的产品族很方便,但是增加产品等级结构很麻烦,

1. 增加产品族: 抽象工厂模式很好的支持了开闭原则,只需要增加具体产品并对应增加一个新的具体工厂,对以后有代码无须做任何修改
2. 增加新的产品等级结构 : 对于增加新的产品等级结构,需要修改所有的工厂角色包括抽象工厂类,在所有工厂中都需要增加生产新产品的方法,违背了开闭原则



## 5.5	抽象工厂模式优缺点与适用环境



优点:	主要是隔离了具体类的生成,使得客户端并不需要知道什么被创建,当一个产品族中的多个对象被设计在一起工作时,它能够保证客户端始终只使用同一个产品族中的对象;新增产品族方便,无须修改已有系统,符合开闭原则

缺点:	主要是增加产品等级结构麻烦,需要对原有的系统进行修改,违背开闭原则



适用环境: 一个系统不应当被依赖于产品类实例如何创建 组合和表达的细节,系统中有多于一个的产品族,而每次只使用某一个产品族,属于同一个产品族的产品将在一起使用,这一约束必须在系统的设计中体现出来,产品等级结构稳定,在设计完成之后不会向系统同增加新的产品等级结构或删除已有产品等级结构



# 第六章	建造者模式

## 6.1	建造者模式概述

建造者模式是一种较为复杂的创建型模式,他将客户端与包含多个组成部分的复杂对象的创建过程分离,客户端无须知道复杂对象的内部组成部分与装配方式, 只需要知道所需建造者的类型即可,

将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示

例如: 汽车由 方向盘,轮胎,发动机组成的



## 6.2	建造者模式结构与实现

### 6.2.1	建造者模式结构

Builder(抽象建造者):	它为创建一个产品对象的各个部件指定抽象接口,在该接口中一般声明两类方法,一类方法是buildPartX() 他们用于创建复杂对象的各个部件,另一类方法是getResult()他们用于返回复杂对象,Builder()即可以是抽象类也可以是接口

ConcreteBuilder(具体建造者):	实现了Builder接口,实现各个部件的具体构造和装配方法,定义并明确所创建的复杂对象,还可以提供一个方法返回创建好的复杂产品对象

Proudct(产品):	他是被构建的复杂对象,包含多个组成部件,具体建造者创建该产品的内部表示并定义它的装配过程

Director(指挥者):	指挥者有称为导演类,她负责安排复杂对象的建造次序,指挥者与抽象建造者之间存在关联关系,客户端一般只需要与指挥者进行交互,在客户端确定具体建造者的类型并实例化具体建造者对象,然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中

### 6.2.2	建造者模式实现

## 6.3	建造者模式优缺点和适用环境

### 6.3.1	建造者模式优点 缺点

优点

1. 在建造者模式中,客户端不必知道产品内部组成的细节,将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象
2. 每一个具体建造者都相对独立,而与其他的具体建造者无关,因此可以很方便的替换具体建造者或者增加建造者,由于指挥者类针对抽象建造者编程,增加的新的具体建造者无须修改原有类库的代码,系统扩展方便符合开闭原则
3. 可以更加精细的控制产品的创建过程,将复杂产品的创建步骤分解在不同的方法中,使得创建过程更加清晰,也方便适用程序来控制创建过程

缺点

1. 建造者模式所创建的产品一般具有较多的共同点,其组成部分相似,入股哦产品之前差异很大 不适合适用建造者模式,因此使用范围受到一定的限制
2. 如果产品的内部变化复杂,可能会导致需要定义很多具体建造者类来实现这种变化,导致系统变得很庞大,增加系统的理解难度和运行成本



### 6.3.2	建造者模式适用环境

1. 需要生成的产品对象由复杂得分内部结构,这些产品对象通常包含多个成员变量
2. 需要生成的产品对象的属性相互依赖,需要指定其生成的顺序
3. 对象的创建过程独立于创建 该对象的类,在建造者模式中通过引入指挥者类将创建过程封装在指挥者类中,而不再建造者和客户类之间
4. 隔离复杂对象的创建和适用,并使得相同的创建过程可以创建不同的产品

### 

# 第七章	原型模式

## 7.1	原型模式概述

是一种特殊的创建型模式,通过复制一个已有对象来获取更多相同或者相似对象,

适用原型实例指定待创建对象的类型,并且通过复制这个原型来创建新的对象

工作原理：将一个原型对象传给要发动创建的对象,这个要发动创建的对象通过请求原型对象复制自己来实现创建过程

## 7.2	原型模式结构与实现

1. Prototype(抽象原型类) 声明克隆方法的接口, 是所有具体原型类的公共父类,它可以是抽象类也可以是接口,或者实现类
2. ConcretePrototype(具体原型类) 实现在抽象原型类中声明的克隆方法,在克隆方法中返回自己的一个克隆对象
3. Client(客户类) 在客户类中让一个原型对象克隆自身从而创建一个新的对象只需要直接实例化或者通过工厂方法等方式创建一个原型对象,再通过调用该对象的克隆方法即可得到多个相同的对象

### 7.2.1  浅克隆(Shallow clone)与深克隆(Deep clone)

浅克隆

​	当原型对象被复制时只复制它本身和其中包含的值类型的成员变量,而引用类型的成员变量并没有复制

深克隆

​	无论原型对象的成员变量是值类型还是引用类型都将复制一份给克隆对象,深克隆将原型对象的所有引用对象也复制一份给克隆对象

#### Java语言中clone()方法满足一下几点

1. 对任何对象X 都有x.clone()!=x 即克隆对象与原型对象不是同一个对象
2. 对任何对象x 都有x.clone().getClass() == x.getClass(),即克隆对象与原型对象的类型一样
3. 如果对象x 的equals()方法定义恰当,那么x.clone().equals(x) 应该成立



## 7.3	原型模式优缺点与适用环境

优点

1. 当创建新的对象实例较为复杂时 ,使用原型模式可以简化对象的创建过程,通过复制一个已有是咧可以提高新实例的创建效率
2. 扩展性较好,由于在运行模式中提供了抽象原型类,在客户端可针对抽象原型类进行编程,而将具体圆形类写在配置文件中,增加或减少产品类对原有系统没有任何影响
3. 原型模式提供了简化的创建结构,工厂方法模式常常需要有一个与产品等级结构相同的工厂等级结构,而原型模式就不需要这样,原型模式中产品的复制是通过封装在原型类中的克隆方法实现,无须专门的工厂类来创建
4. 可使用深克隆的方式保存对象的状态, 使用原型模式将对象复制一份并将其状态保存起来,以便在需要的时候使用,可辅助实现撤销操作

缺点

1. 需要为每一个类配备一个克隆方法,而且该克隆方法位于一个类的内部,当对已有的类进行改造是需要修改源代码,违背了开闭原则
2. 在实现深克隆是需要编写较为复杂的代码,而且当对象之间存在多重嵌套引用时,为实现深克隆,每一层对象对应的类都必须支持深克隆,实现起来可能比较麻烦

适用环境

1. 创建新对象成本较大,新对象可以通过复制已有对象来获得,如果是相似对象,则可以对其成员变量稍作修改
2. 系统要保存对象的状态,而对象的状态变化很小
3. 需要避免适用分层次的工厂类创建分层次对象,并且类的实例对象只有一个或者很少几个组合的状态,通过复制原型对象创建



# 第八章	单例模式

## 8.1	单例模式概述

单例模式是结构最简单的设计模式,在他的核心结构中只包含一个被称为单例的特殊类,通过单例模式可以确保系统中一个类只有一个而且改实列易于被外界访问,从而方便对实例个数进行控制,节约系统资源

确保一个类只有一个实例,并提供一个全局访问点来访问这个唯一的实例

在单例模式实现过程中需要注意的是:

1. 单例类构造函数的可见性为private
2. 提供一个类型为自身的静态私有成员变量
3. 提供一个公有的静态工厂方法

## 8.2  单例模式结构与实现





## 8.3	饿汉式单例与懒汉式单例

饿汉式

​	当类被加载时,静态变量instance会被初始化,此时类得私有构造函数会被调用,单例类得唯一实例将被创建

懒汉式

​	懒汉式的单例类在第一次被引用时将自己实例化,在懒汉式单例加载时不会将自己实例化,

​	为了避免多个线程同时调用getInstance()方法,可以使用 关键字synchronized 虽然解决了线程安全问题,但是每次调用getInstance()时都需要进行线程锁定判断,在多线程高并发访问环境中将会导致系统得性能大大降低,升级为锁定代码块,但是又会出现在某一个瞬间线程A 和线程B 同时调用getInstance()方法,B线程在排队中,当A 线程执行完成后,B 线程并不知道已经创建了实例对象,将继续创建B 的实例对象,导致产生多个单例对象,违背了单例模式的设计思想, 使用双重检查锁定



饿汉式和懒汉式的对比

​	饿汉式类加载时加载不需要考虑多线程问题,可以确保唯一性,从调用速度和反应时间来讲时由于懒汉式的,但是由于不管是否使用该实例系统加载时都需要创建饿汉式单例对象会消耗资源和加载时间长

懒汉式

​	无须占用系统资源,延迟加载,需要处理多线程问题,

## 8.4	单例模式优缺点 与使用环境

优点

​	主要在于提供了对唯一实例的受控访问并可以节约系统资源

缺点

​	主要在于因为缺少抽象层而难以扩展,并且单例类责任比较重,将太多功能耦合在一起

使用环境

​	系统只需要一个实例对象,客户调用类的单个实例只允许使用一个公共的访问点

# 第九章	适配器模式

## 9.1	适配器模式概述

适配器模式是一种使用频率非常高的结构型设计模式,如果再系统中存在不兼容的接口,可以通过引入一个适配器来使岩本因为接口不兼容而不能一起工作的两个类能够协调工作

将一个类的接口转换成客户希望的另一个接口,适配器模式让那些接口不兼容的类可以一起工作

## 9.2	适配器模式结构与实现

### 9.2.1	适配器模式结构

1. Target(目标抽象类) 目标抽象类定义客户所需的接口,可以是一个抽象类或者接口,也可以是具体类,再适配器中,由于java语言不支持多重继承它只能是接口
2. Adapter(适配器类) 它可以调用另一个接口,作为一个转换器,对Adaptee和Target进行适配,适配器Adapter是适配器模式的核心,在类适配器中,它铜鼓哦实现Target接口并继承Adaptee类来使二者产生联系,在对象适配器中,它通过继承target并关联一个Adaptee对象使二者关联
3. Adaptee(适配者类) 适配者即适配的角色,它定义了一个已经存在的接口,这个接口需要适配,适配者类一般是一个具体类,包含了客户希望使用的业务方法,在某些情况下甚至没有适配者类的源代码

### 9.2.2    适配器模式实现



## 9.3	适配器模式优缺点与适用环境

对象适配器和类适配器 优点:

1. ​	将目标类和适配者类解耦,通过引用一个适配器类来宠用先有后的适配者类,无须修改原有结构
2. 增加了类的透明性和复用性,将具体的业务实现过程封装在适配者类中,对于客户端类而言是透明的,而且提高了适配者的复用性,同一个适配者类可以在多个不同的系统中复用,
3. 灵活性和扩展性都非常好,通过适用配置文件可以很方便的更换适配器,也可以在不修改原有代码的基础上增加新的适配器类,完全农夫和开闭原则

对象适配器模式优点:

1. ​	一个对象适配器可以把多个不同的适配者适配到一个目标
2. 可以适配一个适配者的子类,由于适配器和适配者之间是关联关系,根据里氏代换原则,适配者的子类也可以通过该适配器进行适配

类适配器缺点:

1. ​	对于java等不支持多重类继承的语言,一次最多只能适配一个适配者类,
2. 适配者类不能为最终类,不能是final类
3. 在java 语言中,类适配模式中的目标抽象类只能是接口,不能为类,其实用有一定的局限性

对象适配器缺点

​	与类适配器模式相比,在该模式下要在适配器中替换适配者类的某些方法比较麻烦,如果一定要置换掉适配者类的一个或多个方法,可以先做一个是适配者类的子类,将适配者类的方法置换,然后再适配者类的子类当成真正的适配者进行适配,

适用环境

1. 系统需要适用一些现有的类,而这些类的接口不符合系统的需要,甚至没有这些类的源代码
2. 向创建一个可以重复适用的类,用于和一些彼此之间没有太大联系的类一起工作



# 第十章	桥接模式

## 10.1 	桥接模式概述

桥接模式是一种很适用的结构型设计模式,如果系统中的某个类存在两个独立变化的维度,通过桥接模式可以将这两个维度分离出来,使得两者可以独立拓展

蜡笔 : 颜色和大小型号 存在较强和耦合性

毛笔: 颜色和大小型号,就是两个不同的维度,

桥接模式: 将抽象部分与它实现部分解耦,使得两个能够独立变化

## 10.2	桥接模式结构和实现

### 10.2.1	桥接模式结构

1. Abstracton(抽象类) 它是用于定义抽象类的接口,通常是抽象类而不是接口,其中定义了一个Implementor(实现类接口)类型的对象并可以维护该对象,它与Implementor之间具有关联关系,它即可以包含抽象业务方法,也可以包含具体业务方法
2. RefinedAbstraction(扩充抽象类) 它扩充有Abstraction 定义的接口,通常情况下它不再是抽象类而是具体类,实现了Abstraction 中声明的抽象业务方法,再RefinedAbstraction 中可以调用再Implementor中定义的业务犯法
3. Implementor(实现类接口) 定义实现的接口,这个接口不一定要与Abstraction的接口完全一直,事实上这两个接口可以完全相同
4. ConcreteImplementor(具体实现类) 具体实现了Implementor接口,再不同ConcreteImplementor中提供基本操作的不同实现,在程序运行时ConcreteImplementor对象将替换其父类对象,提供给抽类具体的业务操作方法

### 10.2.2    桥接模式的实现



### 10.2.3	桥接模式与适配器模式的联用

适配器模式可以解决两个已有接口间不兼容的问题,在这中情况下被适配的类往往时一个黑盒子,有时候不想也不能改变这个被适配的类,也不能控制器扩展

适配器模式通常用于现有系统与第三方产品功能的集成,采用增加适配器的方式将第三方类集成到系统中,

桥接模式则不同,用户可以通过接口集成或类集成的方式对系统进行扩展

桥接模式用于系统初步设计,对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个不同角色,他们可以分别进行变化,而初步设计完成后,当发现系统与育有类无法协同工作时采用适配器模式



## 10.3	桥接模式优缺点与适用环境

桥接模式时设计java虚拟机和实现JDBC等驱动程序的核心模式之一,应用较为广泛,

优点:

1. 分离抽象接口机器实现部分,桥接模式适用"对象间的关联关系"解耦了抽象和实现之间固有的绑定关系,使得抽象和实现可以沿着各自的维度来变化,
2. 桥接模式取代了多层继承方案,多层继承方案违背了单一职责原则,复用性差,并且类的个数非常多,桥接模式时比多层继承方案更好的解决方法,它极大的减少了子类的个数
3. 桥接模式提高了系统的可扩展性,在两个变化维度中任意扩展一个维度都不需要修改原有系统, 符合开闭原则

缺点:

1. ​	桥接模式的适用会增加系统的理解和设计难度,由于关联关系建立在抽象层,要求开发者一开始就针对抽象层进行设计与编程
2. 桥接模式要求正确的识别出系统中两个独立变化的维度,因此其适用范围具有一定的局限性,

适用环境:

1. 如果一个系统需要在抽象化和具体化之间增加更多的灵活性,避免在两个层次之间建立静态继承关系,通过桥接模式可以使他们在抽象层建立一个关联关系
2. 抽象部分和实现部分可以用继承的方式独立扩展而互不影响,在程序运行时可以动态的将一个抽象化子类的对象和一个实现化子类的对象进行组合,即系统需要对抽象化角色和实现化角色进行动态耦合
3. 一个类存在两个或多个独立变化的维度且这两个或多个维度都需要独立进行扩展
4. 对于那些不希望使用继承或因多层继承导致系统类的个数急剧增加的系统,桥接模式尤为适用



# 第十一章	组合模式

## 11.1	组合模式概述

组合模式关注那些包含叶子构件和容器构建的结构以及他们组织形式,在叶子构件中不包含成员对象,而容器构件中可以包含成员对象,这些对象通过递归组合可构成一个树形结构

组合模式: 组合多个对象形成树形结构以表示具有部分-整体关系的层次结构,组合模式让客户端可以同意对待单个对象和组合对象



## 11.2	组合模式结构和实现

### 11.2.1	组合模式结构

1. Component(抽象构件) 它可以是接口或抽象类,为叶子构件和容器构件对象声明接口,在该角色中可以包含所有子类共有行为的声明和实现,在抽象构件中定义了访问及管理它的子构件的方法,如增加子构件,删除子构件获取子构件
2. Leaf(叶子构件) 它在组合结构中表示叶子节点对象,叶子节点没有子节点,它实现了在抽象构件中定义的行为,对于那些访问及管理子构件的方法,可以通过抛出异常,提示错误等方式进行处理
3. Composite(容器构件)  它在组合结构中表示容器结点对象,容器结点包含子结点,其子结点可以时叶子结点,也可以是容器结点,它提供了一个集合用于储存子结点,实现了在抽象构件中定义的行为,包括那些访问及管理子构件的方法,在其业务方法那种可以递归调用子结点的业务方法



### 11.2.2	组合模式实现





## 11.3	透明组合模式与安全组合模式

1. 透明组合模式在抽象构件Component 中声明所有用于管理成员对象的方法,包括add() 等,这样做的好处是确保所有的构件类都是相同的接口, 在客户端看来,叶子对象和容器对象所提供的方法是一致的,客户端可以一致对待所有接口

    透明组合模式缺点是不够安全,因为叶子对象和容器对象本质上是由区别的, 

2. 安全模式组合中,抽象构件Component 中没有声明任何管理成员对象的方法,而是在Composite类中声明并实现这些方法,这样做法是安全的, 因为根本不想叶子对象提供这些管理成员对象的方法,



## 11.4	组合模式优缺点与适用环境

组合模式适用面向对象的思想来实现树形结构的构件与处理,描述了如果将容器对象和叶子对象进行递归组合实现简单灵活性好,适用频率高



优点:

1. ​	可以清楚的定义分层次的复杂对象,表示对象的全部或者部分层次,可以让客户端忽略了层次的差异, 方便对整个层次结构进行控制
2. 客户端可以一致的适用一个组合结构或其中单个对象,不必关心处理的是单个对象还是整个组合结构,简化了客户端代码
3. 在组合模式中增加新的容器构件和叶子构件都很方便,无须对现有类库进行任何修改,符合开闭原则
4. 为树形结构的面向对象实现提供了一个灵活的解决方案,通过叶子对象和容器对象的递归组合可以形成复杂的树形结构,但对树形结构的控制却非常简单

缺点

1. ​	在增加新构件时很难对容器中的构件类型进行限制,有时候一个容器中只能由某些特定类型的对象,例如在某个文件夹中只能包含文本文件,在适用组合模式时不能依赖类型系统来施加这些约束,因为他们都来自于相同的抽象层, 在这情况下必须通过运行时进行类型检查来实现,整个实现过程复杂



适用环境

1. 在具有整体和部分的层次结构中希望通过一种方法忽略整体和部分的差异,客户端可以一致的对待他们
2. 在一致适用面向对象语言开发的系统中需要处理一个树形结构
3. 在一个系统中能够分类出叶子对象和容器对象,而且他们的类型不固定,需要增加一些新的类型





# 第十二章 	装饰模式

## 12.1	装饰模式概述

装饰模式是一种用于替代继承的技术,它通过一种无须定义子类的方式来给对象动态增加职责, 适用对象之间的关联关系之间的继承关系. 装饰模式降低了系统的耦合度,可以动态增加或删除对象的职责,并使需要装饰的具体构件类和用于装饰的具体装饰类都可以独立变化,增加新的具体构建类和具体装饰类,都是非常方便的,符合开闭原则

装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为

装饰模式 动态的给一个对象增加一些额外的职责, 就口占功能而言,装饰模式提供了一种比适用子类更加灵活的替代方案



## 12.2	装饰模式结构与实现

### 12.2.1	装饰模式结构

1. Component(抽象构件) 它是具体构件和抽象装饰类的共同父类,声明了在具体构件中实现的业务方法,它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象,实现客户端透明操
2. ConcreteComponent(具体构件) 他是抽象构件类的子类,用于定义具体的构件对象,实现了在抽象构件中声明的方法,装饰类可以给它增加额外的职责
3. Decorator(抽象装饰类)  他是抽象构件类的子类,用于给具体构件增加职责,但是具体职责在其子类中实现,它维护一个指向抽象构件对象的引用,通过该引用可以调用装饰之前构件对象的方法,并通过子类扩展该方法,以达到装饰的目的
4. ConcreteDecorator(具体装饰类)  他是抽象装饰类的子类,负责向构件添加新的职责,每一个就打装饰类都定义了一些新的行为,它可以调用在抽象装饰类中定义的方法,并可以增加新的方法用于扩充对象的行为

### 12.2.2  装饰模式实现





## 12.3	透明装饰模式和半透明装饰模式

透明装饰模式

装饰模式中,具体装饰类通过新增成员变量或者方法来扩充具体构件类的功能,在标准的装饰模式中,新增行为需在原有业务方法中调用,无论是具体构件对象还是i装饰过的构件对象,对于客户端而言都是透明的,这种装饰模式成为透明装饰模式

透明装饰模式可以让客户端透明地使用装饰前的对象和装饰之后的对象,无须关心他们的区别,此外还可以对一个已装饰过的对象进行多多次装饰,得到更加复杂,功能更加强大的对象



半透明装饰模式

透明装饰模式的设计难度较大,而且有时需要单独调用新增的业务方法,为了能够调用到新增方法,不得不用具体装饰类来定义装饰之后的对象,而具体构件类型仍然可以使用抽象构件类型来定义, 这种装饰模式为半透明装饰模式

半透明装饰模式可以给系统带来更多的灵活性, 设计相对简单,使用起来也非常方便,但是其最大的缺点在于不能实现对同一个对象的多次装饰,而且客户端需要有区别的对待装饰之前的对象和装饰之后的对象



## 12.4	装饰模式的优缺点与适用环境

优点

1. ​	对于扩展一个对象的功能,转世模式比继承更加灵活,不会导致类的个数急剧增加
2. 可以通过一种动态的方式扩展一个对象的功能,通过配置文件可以在运行时选择不同的具体装饰类,从而实现不同的行为
3. 可以对一个对象进行多次装饰,通过适用不同的具体装饰类以及这些装饰类的排列组合可以创造出很多不同的行为组合,得到功能更加强大的对象
4. 具体构件类与具体转世类可以独立变化,用户根据需要增加新的具体构件类和具体装饰类,原有类库代码无须改变,符合开闭原则

缺点

1. ​	在使用装饰模式进行系统设计时将产生很多小对象,这些对象的区别在于他们之间相互联系的方式有所不同,而不是他们的类或者属性值有所不同,大量小对象的产生势必会占用更多系统资源,在一定程度上影响程序的性能
2. 装饰模式提供了一种比继承更加灵活,激动的解决方案,但同时意味着比继承更加容易出错,排错更加困难,对于多次装饰的对象,在调试时寻找错误可能需要逐级排查,较为繁琐

适用环境

​	在不影响其他对象的情况下以动态,透明的方式给单个对象添加职责,但不能采用继承的方式对系统进行扩展或采用继承不利于系统扩展和维护时可以使用装饰模



# 第十三章 	外观模式(门面模式)

## 13.1	外观模式概述

外观模式是一种使用频率非常高的结构型设计模式,它通过引入一个外观角色来简化客户端与子系统之间的交互,为复杂的子系统调用提供一个统一的入口,使子系统与客户端的耦合度降低,且客户端调用非常方便

自己泡茶和酒馆泡茶的差别

在外观模式中,一个子系统的外部与其内部通信通过一个统一的外观类进行,外观类将客户类与子系统的内部复杂性分隔开来,使得客户类只需要与外观角色大较大,而不需要与子系统内部的很多对象打交道

外观模式: 为子系统中的一组接口提供一个统一的入口,外观模式定义了一个高层接口,整个接口使得这一子系统更加容易使用

## 13.2	外观模式结构与实现

### 13.2.1 外观模式结构

1. Facade(外观角色) 在客户端可以调用它的方法,在外观角色中可以知道(一个或者多个)子系统的功能和责任,在正常情况下,它将所有客户端发来的请求委派到响应的子系统,传递相应的子系统对象处理
2. SubSystem(子系统对象) 在软件系统中可以有一个或者多个子系统角色,每一个子系统可以不是一个单独的类,而是一个类的集合,它实现子系统的功能,每一个子系统都可以被客户端直接调用,或者被外观角色调用,它处理由外观类传过来的请求,子系统并不知道外观的存在,对于子系统而言,外观角色斤进是另一个客户端而已

### 13.2.2   外观模式实现



## 13.3	抽象外观类

在标准外观模式结构中,如果需要增加,删除或者修改与外观类交互的子系统类, 必须修改外观类或者客户端的源代码,这违背可开闭原则,因此引入抽象外观类对系统进行改进,





## 13.4	外观模式优缺点与适用环境

优点

1. ​	他对客户端屏蔽了子系统组件,减少了看客户端所需处理的对象数目, 并使子系统适用起来更加容易,通过引入外观模式,客户端代码将变得更加简单,与之关联的对象也很少
2. 它实现了子系统与客户端之间的松耦合关系,使得子系统的变化不会影响调用它的客户端,只需要调整外观类即可
3. 一个子系统的修改对其他子系统没有任何影响而且子系统内部变化也不会影响到外观系统

缺点

1. ​	不能很好的限制客户端直接适用子系统类,如果对客户端访问子系统类做太多的限制则减少了可变和灵活性
2. 如果设计不当,增加的子系统可能需要修改外观类的源代码,违背了开闭原则

适用环境

1. 当要为访问一系类复杂的子系统提供一个简单入口时,可以适用外观模式
2. 客户端程序与多个子系统之间存在很大的依赖性,引入外观类可以将子系统与客户端解耦,从而提高子系统的独立性和可移植性
3. 在层次化结构中可以适用外观模式定义系统中每一层的入口, 层与层之间不直接残生联系,而通过外观类建立联系,降低层之间的耦合度



# 第十四章	享元模式

## 14.1	享元模式概述

当系统中村咋i大量相同或者相似的对象时,享元模式时一种值得考虑的解决方案,它通过共享技术实现相同或相似的细粒度对象的复用,从而节约了内存空间,提高了系统性能

享元模式以共享的方式高效地支持大量细粒度对象的重用 ,享元对象能够做到共享的关键是区分了内部状态和外部状态,

1. 内部状态(Intrinsic State) 时存储在享元对象内部并且不会随环境改变而改变的状态,内部状态可以共享
2. 外部状态(Extrinsic State) 是随着环境改变而改变的, 不可以共享的状态,享元对象的外部状态通常由客户端保存, 并在享元对象被创建之后需要使用的时候再传入到享元对象内部

享元模式运用共享技术有效地支持大量细粒度对象的复用



## 14.2	享元模式结构与实现

### 14.2.1	享元模式结构

1. Flyweight(抽象享元类)  抽象享元类通常是一个接口或抽象类,在抽象享元类中声明了具体享元类公共的方法,这些方法可以向未接提供享元对象的内部数据,同时也可以通过这些方法来设置外部数据
2. ConcreteFlyweight(具体享元类)  具体享元类实现了抽象享元类,其实例称为享元对象,在具体享元类中为内部状态提供了存储空间,通常可以结合单例模式设计具体享元类,为每一个具体享元类提供唯一的享元对象
3. UnsharedConcreteFlyweight(非共享具体享元类) 并不是所有的抽象享元类的子类都需要被共享,不能被共享的子类可以设计为非共享具体享元类,当需要一个非共享具体享元类的对象时可以直接通过实例化创建
4. FlyweightFactory(享元工厂类) 享元工厂类用于创建并管理享元对象,它针对抽象享元类编程,将各种类型的具体享元对象存储在一个享元池中,享元池一般设计为一个存储键值对的集合,可以结合工厂模式进行设计,当用户请求一个具体享元对象时,享元纳工厂提供一个储存享元池中已创建的实例或者创建一个新的实例,返回新创建的实例并存储在享元池中



### 14.2.2	享元模式实现



## 14.3	有外部状态的享元模式



## 14.4	单纯享元模式与复合享元模式

1. 单纯享元模式 中所有的具体享元类都是可以共享的,不存在非共享具体享元类
2. 符合享元模式 向一些单纯享元对象使用组合模式加以组合还可以形成复合享元对象,这样的复合享元对象本身不共享,但他们可以分解成单纯享元对象,而后者可以共享



## 14.5	享元模式与String 类





## 14.6	享元模式优缺点与适用环境

优点

1. ​	享元模式可以减少内存中对象的数量,使得相同或者相似对象在内存中只保存一份,从而可以节约系统资源,提高系统性能
2. 享元模式的外部状态相对独立,而且不会影响其内部状态,从而使享元对象可以在不同的环境中被共享

缺点

1. ​	享元模式使系统变得复杂,需要分离出内部状态和外部状态,这使得程序的逻辑复杂哈
2. 为了使对象可以共享,享元模式需要将享元对象的部分状态外部化,而读取外部状态使运行时变长

适用环境

1. 一个系统有大量相同或者相似的对象,造成内存的大量消耗
2. 对象的大部分状态都可以外部化,可以将这些外部状态传入对象中
3. 在适用享元模式时需要维护一个存储享元对象的享元池,而这需要耗费一定的系统资源,因此应当需要多次重复使用享元对象时才使用享元模式





# 第十五章	代理模式

## 15.1	代理模式概述

代理模式是常用的结构设计模式这一,当无法直接访问某个对象或访问某个对象存在困难时可以一个代理对象来简介访问,为了保证客户端使用的透明性,所访问的真是对象和代理对象需要实现相同的接口



代理模式	: 给某一个对象提供一个代理或占位符,并由代理对象来控制对原对象的访问



## 15.2	代理模式结构与实现

### 15.2.1	代理模式结构

1. subject(抽象主题角色) 它声明了真是主题和代理主题的共同接口,这样一来在任何使用真实主题的地方都可以使用代理主题,客户端通常需要针对抽象主题角色进行编程
2. Proxy(代理主题角色) 它包含了对真实主题的引用,从而可以在任何时候操作真实主题对象,在代理主题角色中提供了一个真实主题角色相同的接口,一边在任何时候都可以替代真实主题,代理主题角色还可以控制对真实主题的使用,负责在需要的时候创建和删除真实主题对象,并对真实主题对象的使用加以约束
3. RealSubject(真实主题角色)它定义了代理角色代表的真实对象,在真实主题角色中实现了真实的业务操作,客户端可以通过代理主题角色简介调用真实主题角色定义的操作



### 15.2.2 	代理模式实现



## 15.3	远程代理

远程代理是一种常用的代理模式,它使得客户端程序可以访问在远程主机上的对象,远程主机可能具有更好的计算性能与处理速度,可以快速响应并处理客户端的请求,



## 15.4	虚拟代理

虚拟代理也是常用的代理模式,对于一些占用系统资源较多或者加载时间较长的对象,而可以给这写对象提供一个虚拟代理,在真实对象创建成功之前虚拟代理扮演真实对象的替身,而真实对象创建之后虚拟代理将用户的请求转发给真实对象

通常在一下两种情况下可以考虑使用虚拟代理

1. 由于对象本身复杂性或者网络等原因导致一个对象需要较长时间加载,此使可以使用一个加载时间较短的代理对象来代表真实对象,
2. 当一个对象的加载十分消耗系统资源的时候也非常适合使用虚拟代理,虚拟代理可以让那些占用大量内存或者处理起来非常复杂的对象推迟到使用他们的时候才创建,而在次之前用一个相对来说占用资源较少的代理对象来代表真实对象,再通过代理对象来引用真实对象



## 15.5	Java动态代理



## 15.6	代理模式优缺点与适用环境

优点

1. ​	能够协调调用者和被调用者再一定程度上降低了系统的耦合性
2. 客户端可以针对抽象主题角色进行编程,增加和更换代理类无须修改源代码,符合开闭原则,系统具有较好的灵活性和扩展性

不同代理模式的优点

1. 远程代理位于两个不同地址空间的对象访问提供了一种实现机制,,可以将一些消耗资源较多的对象和操作移至性能更好的计算机上,提高系统整体运行的效率
2. 虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象,可以在一定程度上节省系统的运行开销
3. 缓冲代理,为某一个操作的结果提供临时的缓存存储空间,以便后续使用中能够共享这些结果,优化系统性能,缩短执行时间
4. 保护代理可以控制对一个对象的访问权限,为不同用户提供不同级别的使用权限

缺点

1. 由于客户端和真实主题之间增加了代理对象,因此有些类型的代理模式可能会造成请求的处理速度变慢,
2. 实现代理模式需要额外的工作,而且有些代理模式的实现过程较为复杂

适用环境

1. 客户端对象需要访问远程主机中的对象是可以使用远程代理
2. 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象,从而降低系统开销,缩短运行时间时可以使用虚拟代理,
3. 当需要为某一个被频繁访问的操作结果提供一个临时缓存存储空间,以供多个客户端共享访问这些结果时可以使用缓冲代理,通过使用缓冲代理系统无须再客户端每一次访问时都重新执行操作,只需直接从临时缓冲区获取操作结果即可
4. 当需要控制对一个对象的访问为不同用户提供不同级别的访问权限时可以使用保护代理
5. 当需要为一个对象的访问提供一些额外的操作时,可以使用智能引用代理



# 第十六章	职责链模式

## 16.1	职责链模式概述

在系统中如果存在多个对象可以处理同一请求,则可以通过职责链模式将这些处理请求的对象连成一条链,让请求沿着该链进行传递,如果链上对象可以处理请求则进行处理,否则将请求转发给下家处理,职责链模式可以将请求的发送者和接收者解耦,客户端无须关心请求的处理的细节和传递过程



职责链模式 避免将一个请求的发送者与接收者耦合在一起,让多个对象都有机会处理请求,将接收请求的对象连接成一条链,并且沿着这条链传递请求,直到有一个对象能够处理它位置

## 16.2	职责链模式结构与实现

### 16.2.1	职责链模式结构

1. Handler(抽象处理者) 它定义了一个处理请求的接口,一般设计为抽象类,由于不同的具体处理者处理请求的方式不同,因此在其中定义了抽象请求处理方式
2. ConcreteHandler(具体处理者) 它时抽象处理者的子类,可以才处理用户请求,在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法,咋i处理请求之前需要进行判断,看是否有相应的处理权限,如果可以处理请求就处理它,否则将请求转发给后继承者,在具体处理者中可以访问链中的下一个对象以便请求的转发



### 16.2.2	职责链模式的实现



## 16.3	纯与不纯的职责链模式

1. 纯的职责链模式

一个纯的职责链模式要求一个具体处理对象只能在两个行为中选择一个,要么承担全部职责,要么职责 推给下家,不允许出现某一个具体对象在承担了一部分或全部职责后有将职责向下传递的情况,而且在纯的职责链模式中要求一个请求必须被某一个处理者对象所接收,不能出现某个请求未被任何一个处理对象处理的情况

	2. 在一个不纯的职责链模式中允许某一个请求被一个具体处理者部分处理后再向下传递,或者一个具体处理者处理完某请求后其后继处理者可以继续处该请求,而且一个请求可以最终不被任何处理者对象所接收并处理



## 16.6	职责链模式优缺点与适用环境

优点	

1. 职责链模式使得一个对象无须知道时其他哪一个对象处理其请求,对象仅需知道该请求会被处理即可,接收者和发送者都没有对象明确的信息,并且链中的对象不需要知道链的结构,由客户端负责链的创建,降低系统的耦合度
2. 请求处理对象仅需维持一个只想其后者的引用,而不需要维持它对所有的候选处理者的引用,可简化对象之间的相互连接
3. 在给对象分配职责时,职责链可以带来更多的灵活性,可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责
4. 在系统中增加一个新的具体请求处理时无须修改原有系统的代码,只需要在客户端重新建链即可,从这点来看是符合开闭原则

缺点

1. 由于一个请求没有明确的接收者,那么就不能保证它一定被处理, 该请求可能一直到链的末端都得不到处理, 一个请求也可能因职责链没有被正确的配置而得不到处理
2. 对于较长的职责链,请求的畜栏里可能设计多个处理对象,系统性能将受到一定的影响,而在机型代码调试时不太方便, 
3. 如果建链不当,可能会造成循环调用,将导致系统陷入死循环



适用环境

1. 由多个给对象可以处理同一个请求,具体那个对象处理该请求待运行时刻在确定,客户端只需要将请求提交到脸上,而无须关心请求的处理对象是谁以及它时如何处理的
2. 在不明确指定接收者的情况下向对象中的一个提交一个请求
3. 可动态指定一组对象处理请求,客户端可以动态创建职责链来处理请求,还可以改变链中处理者之间的先后次序



# 第十七章	命令模式

## 17.1	命令模式概述

他将请求发送者与请求接收者解耦,请求发送者通过命令对象来间接应用接收者,使得系统具有更好的灵活性,可以在不修改现有系统源代码的情况下让相同的发送者对应不同的接收者

将一个请求封装为一个对象,从而可用不同的请求对客户进行参数化,对请求排队或者记录请求日志,以及支持可撤销的操作

## 17.2	命令模式结构与实现

### 17.2.1	命令模式结构

1. Command(抽象命令类) 抽象命令类一点时一个抽象类或结构,在其中声明了用于执行请求的execute()等方法,通过这些方法可以调用请求接收者的 相关操作
2. ConcreteCommand(具体命令类) 具体命令类时抽象命令类的子类,实现了在抽象命令中声明的方法,它对具体的接收者对象,将接收者对象的动作绑定其中,具体命令类在实现execute()方法时将调用接收者对象的相关操作
3. Invoker(调用者) 调用者即请求发送者,它通过命令对象来执行请求,一个调用者并不需要在设计时确定其接收者,因此它只与抽象命令类之间存在关联关系,在程序运行时可以将一个具体命令对象注入其中,在调用具体命令对象的方法,从而实现间接调用接收者的相关操作



### 17.2.2	命令模式实现



## 17.3	命令模式优缺点与适用环境

优点

1. ​	降低系统的耦合度,由于请求者与接收者之间不存在直接的引用,因此请求者与接收者之间实现完全解耦,相同的请求者可以对应不同的接收者,同样相同的接收者也可以对应不同的请求者适用,两者之间具有良好的独立性
2. 新的命令可以很容易加入到系统中,由于增加新的具体命令类不会影响到其他类,因此增加新的具体命令类容易,无须修改原有系统源代码,甚至客户端类代码,满足开闭原则
3. 可以比较容易地设计一个命令队列或宏命令
4. 为请求的撤销和回复操作提供了一种设计和实现方案

缺点

​	适用命令模式可能会导致某些系统又过多具体命令类,因此针对每一个对请求接收的调用操作都需要设计一个具体命令类,所以在某些系统中可能需要提供大量的具体命令类,这些将影响命令模式的适用



适用环境

1. 系统需要将请求调用者和请求接收者解耦,使得调用者和接收者不直接交互,请求调用者无须知道接受者的存在,也无须知道接收者是谁,接收者也无须关心何时被调用
2. 系统需要在不同的事件指定请求,将请求排队和执行请求,一个命令对象和请求的初始调用者可以又不同的生命期,换而言之,最初的请求发出者可能已经不在了,而命令本身仍然时活动的,可以通过命令对象去调用请求接收者并且无须关心请求调用者的存在性, 可以通过请求日志文件等机制来具体实现
3. 系统需要支持命令的撤销操作和恢复操作
4. 系统需要将一组操作组合在一起形成宏命令





# 第十八章	解析器模式

## 18.1	解析器模式概述

解析器模式用于描述如何构成一个简单的语言解析器,主要用于适用面向对象语言开发的解析器设计,实际运用比较少

解析器模式 给定一个语言,定义它的文法的一种表示,并定义一个解析器,这个解析器适用该表示来解析语言中的句子



## 18.2	解析器模式结构与实现

### 18.2.1	解析器模式结构

1. AbstractExpression(抽象表达式)在抽象表达式中声明了抽象的解析器操作,他是所有中介符表达式和非终结符表达式的公共父类

2. TerminalExpression(终结符表达式) 终结符表达式时抽象表达式的子类,它实现了与文法中的终结符相关联的解析操作,在句子中的每一个终结符都时该类的一个实例,通常在一个解析器模式中只有少数几个终结符表达式类,他们的实例可以通过非终结符表达式组成较为复杂的句子

3. NonterminalExpression(非终结符表达式) 非终结符表达式也是抽象表达式的子类,它实现了文法中非终结符的解析操作,由于在非终结符表达式可以包换终结符表达式,也可以继续包含非终结符表达式,因此其解析操作一般通过递归的方式完成

4. Context(环境类) 环境类又称为上下文类,它用于存储解析器之外的一些全局信息,通常它临时存储了需要解析的语句

   





### 18.2.2	解析器模式实现



## 18.3	解析器模式优缺点与适用环境

优点

1. 易于改变和扩展文法,
2. 每一条文法规则都可以表示一个类,因此可以方便地实现一个简单的语言
3. 实现文法比较容易,
4. 增加新的解析表达式比较方便,

缺点

1. 对于复杂的文法难以维护
2. 执行效率低

适用环境

1. 可以将一个需要解析执行的语言中的句子表示一颗抽象语法树
2. 一些重复出现的问题可以用一个简单的语言进行表达
3. 一个语言的文法比较简单的
4. 执行效率不是关键问题





# 第十九章	迭代器模式



## 19.1	迭代器模式概述

迭代器模式式一种适用频率非常高得设计模式,迭代器用于对一个聚合对象进行遍历,通过引入迭代器可以将数据得便利功能从聚合对象中分离出来,聚合对象只负责储存数据,而遍历数据由迭代器完成,简化了聚合对象得设计,更加符合单一职责原则得要求

迭代器模式,提供一种方法顺序访问一个聚合对象中得个元素,而又不用暴露该对象的内部表示

## 19.2	迭代器模式结构与实现

### 19.2.1 	迭代器模式结构

1. Iterator(抽象迭代器) 定义了访问和遍历元素的接口,声明了用于遍历数据元素的方法,
2. ConcretrIterator(具体迭代器) 它实现了抽象迭代器接口,完成对聚合对象的遍历,同时再具体迭代器中通过游标来记录再聚合对象中所出的当前位置,再具体是是现实游标通常表示位置的非负整数
3. Aggregate(抽象聚合类) 它用于存储和管理元素对象,声明一个createIterator()方法用于创建一个迭代器对象,充当抽象迭代器工厂角色
4. ConcreteAggregate(具体聚合类) 他是抽象聚合类的子类,实现了再抽象聚合类中声明的createIterator()方法,



### 19.2.2	迭代器模式的实现





## 19.3	迭代器模式优缺点与适用环境

优点

1. 迭代器模式支持一下不同的方式遍历一个聚合对象,再同一个聚合对象上可以定义多种遍历方式,再迭代器模式中,只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法,也可以自己定义迭代器的子类以支持新的遍历方式
2. 迭代器模式简化了聚合类,由于引入了迭代器,再原有的聚合对象中不需要再自行提供数据遍历等发发,这样可以简化聚合类的设计
3. 再迭代器模式中,由于引入了抽象层,增加新的聚合类和迭代器类都很方便,无须修改原有代码,满足开闭原则

缺点

1. 由于迭代器模式将存储数据和遍历数据的职责分离,再增加新的聚合类是需要对应增加新的迭代器类,类的个数成对增加,这一定程度上增加了系统的复杂性
2. 抽象迭代器对的设计难度较大,需要充分考虑到系统将来的扩展,再自定义迭代器时创建一个考虑全面的抽象迭代器不是一个容易的事情

适用环境

1. 访问一个聚合对象的内容而无须暴露它的内部表示,将聚合对象的访问与内部数据的存储分离,使得访问聚合对象时无须了解其内部实现细节
2. 需要为一个聚合对象提供多种遍历方式
3. 为遍历不同的聚合结构提供统一一个接口,再该接口的实现类中为不同的聚合结构提供不同的遍历方式,而客户端可一致性的操作该接口



# 第二十章	中介者模式

## 20.1	中介者模式概述

对于那些对象之间存在复杂交互关系的系统中,中介者模式提供了一个简化复杂交互的解决方案,它通过引入中介者将原本对象之间的两两交互转化为每个对象与中介者之间的交互,中介者可以对对象之间的通信进行控制与协调,降低原有系统的耦合度,使得系统更加灵活也更加易于扩展

中介者模式的动机

1. 如果一个系统中对象之间的联系呈现网状结构,对象之间存在大量的多对多联系,将导致系统非常复杂,这些对象即会影响其他对象,也会被其他对象所影响,这些对象被称为同事对象,他们之间通过彼此的相互作用实现系统的行为,再网状结构中,几乎每个对象都需要与其他对象发生相互作用,而这种相互作用表现为一个对象与另一个对象的直接耦合,将导致一个过度耦合的系统
2. 中介者模式可以使对象之间的关系数量急剧减少,通过引入中介者对象,可以将系统的网状结构变成以中介者为中星状结构,再这个形状结构中,同事对象不在直接与另一个对象联系,它通过中介者对象与另一个对象发生相互作用,中介者对象的存在保证了对象结构的稳定,也就是说系统的结构不会因为新对象的引入带来大量的修改工作

中介者模式 : 定义一个对象来封装一系列对象的交互,中介者模式使各对象之间不需要显式地相互引用,从而使其耦合松散,而且用户可以独立地改变他们之间的交互

## 20.2	中介者模式结构与实现

### 20.2.1	中介者模式结构

1.  Mediator(抽象中介者) 它定义一个接口,该接口用于与各种同事对象之间进行通信
2. ConcreteMediator(具体中介者) 他是抽象中介者的子类,通过协调各个同事对象来实现写作行为,它维持了对各个同事对象的引用
3. Colleague(抽象同事类) 定义各个同事类公有的方法,并声明了一些抽象方法供子类实现, 同时它维持了一个对象抽象中介者类的引用,其他子类可以通过该引用与中介者通信
4. ConcreteColleague(具体同事类) 他是抽象同事类的子类,每一个同事对象再需要和其他同事对象通信时先于中介者通信,通过中介者简介完成与其他同事类的通信,再具体同事类中实现了抽象同事类中声明的抽象方法



### 20.2.2	中介者模式实现



## 20.3	中介者模式优缺点与适用环境

中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星状结构,在这个星状结构中适用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系

优点

1. 中介者模式简化了对象之间的交互,他用中介者和同事的一对多交互替代原有同事之间的多对多交互,一对多关系更加容易理解,维护,和扩展,将原本难以理解的网状结构转换成相对简单的星状结构
2. 可将个同事对象解耦,中介者有利于各同事之间的松耦合,可以独立地改变和复用每一个同事和中介者,增加新的中介者类和新得同事类都比较方便,更好的符合开闭原则
3. 可以减少子类生成,中介者将原本分布于多个对象间的行为集中再一起,改变这些行为你只需要新生成中介者子类即可,这使得各同事类看可以被重用,无须直接对同事类进行扩展

缺点

1. 再具体中介者类中包含大量同事之间交互的细节,可能会导致具体中介者类非常复杂,难以维护

适用环境

1. 系统中对象之间存在复杂的引用关系,系统结构混乱难以理解
2. 一个对象用于引用了其他很多对象并且直接和这些对象通信,导致难以复用该对象
3. 想通过一个中间类来封装多个类中的行为,而又不想生成太多的子类,此时可以通过引入中介者类来实现,在中介者中定义对象交互的公共行为,如果需要改变行为则可以增加新的具体中介者类





# 第二十一章	备忘录模式

## 21.1	备忘录模式概述

备忘录模式是软件系统的月光宝盒,它提供了一种对象状态的撤销实现机制,当系统中某个对象需要恢复到某一个历史状态时可以适用备忘录模式进行设计



备忘录模式 在不被破坏封装的前提下捕获一个对象的内部状态,并在该对象之外保存这个状态,这样可以在以后将对象恢复到原先保存的状态



## 21.2	备忘录模式结构与实现

### 21.2.1 	备忘录模式结构

1. Originator(原发器) 原发器是一个普通的类,它通过创建一个备忘录来存储当前内部状态,也可以适用备忘录来恢复其内部状态,一般将系统中需要保存内部状态的类设计为原发器
2. Memento(备忘录) 备忘录用于存储原发器的内部状态,根据原发器来决定保存那些内部状态,备忘录的设计一边可以参考原发器的设计,根据实际需要确定备忘录类中的属性 需要注意的是,除了原发器本身与负责人类之外,备忘录对象不能直接供其他类适用,原发器的设计在不同的编程语言中实现机制会有所不同
3. Caretaker(负责人) 负责人又称为管理者,它负责保存备忘录,但是不能对备忘录的内容进行操作或检查,在负责人类中可以存储一个或多个备忘录对象,它只负责存储对象,而不能修改对象,也不许知道对象的实现细节



### 21.2.2	备忘录模式实现



## 21.3	备忘录模式优缺点与适用环境

优点

1. 提供了一种状态恢复的实现机制,使得用户可以方便地回到一个特定的历史步骤,当新的主管你太无效或者存在问题是可以使用暂时储存起来的备忘录将状态复原
2. 备忘录实现了对信息的封装,一个备忘录对象是一种原发器对象状态的表示,不会被其他代码所改动,备忘录保存原发器的状态,采用列表,堆栈等集合来存储备忘录对象可以实现多次撤销操作

缺点

1. 资源消耗过大,如果需要保存的原发器类的成员变量太多,就不可避免的需要占用大量的储存空间,每保存一次对象的状态都需要消耗一定的系统资源

适用环境

1. 保存一个对象在某一个时刻的全部状态或部分状态,这样以后需要时它能够恢复到先前的状态,实现撤销操作
2. 防止外界对象破坏一个对象历史状态的封装性,避免将对象历史状态的实现细节暴露给外界对象





# 第二十二章	观察者模式

## 22.1	观察者模式概述

在软件系统中对象并不是孤立存在的,一个对象的行为的改变可能会导致一个或多个其他与之存在依赖关系的对象行为发生变化



定义对象之间的一种一对多的依赖关系,使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并自动更新



## 22.2	观察者模式结构与实现

### 22.2.1	观察者模式结构

1. Subject(目标) 目标又称为主题,它是指被观察的对象,在目标中定义了一个观察者集合,一个观察目标可以接受任意数量的观察者观察,它提供一系列方法来增加和删除观察者对象,同时定义了通知方法notify() 目标类可以是接口 抽象类, 具体类
2. ConcreteSubject(具体目标) 具体目标是目标类的子类,它通常包含由经常发生改变的数据,当它的状态发生改变时将向它的各个观察者发出通知,同时它还实现了在目标类中定义的抽象业务逻辑方法,如果无须扩展目标类,则具体目标类可以省略
3. Observer(观察者) 观察者将对观察目标的改变做出反应,观察者一般定义为接口,该接口声明了更新数据的方法update() 因此又称为抽象观察者
4. ConcreteObserver(具体观察者) 在具体观察者中维护一个指向具体目标对象的引用,它存储具体观察者的有关状态,这些状态需要和具体目标的状态保持一致,它实现了在抽象观察者中定义的update()方法,通常在实现是可以调用具体目标类的attach() 方法将自己添加到目标类的集合中通过detach()方法将自己从目标类集合中删除



### 22.2.2	观察者模式实现





## 22.3	JDK对观察者模式的支持

在JDK的java.util 包中提供了Observable类以及Observer接口,

Observer接口中只声明一个方法,它充当抽象观察者,当观察目标的对象发生变化时该方法将被调用,,在Observer的子类将实现update()方法,即具体观察者可以根据需要具有不同的更新行为,

Observable类 充当观察者目标类, 用户可以直接使用接口和类,作为观察者模式的抽象成,再自定义具体观察者类和具体观察者目标类,



## 22.4	观察者模式与java事件处理

在DEM模型中目标角色(如界面组件)负责发布事件, 而观察者角色(事件处理者)可以向目标订阅它所感兴趣的事情,当一个具体目标产生一个事件时他将通知所有的订阅者,

事件的发布者称为事件源,而订阅者称为事件监听者,在这个过程中还可以通过事件对象来传递与事件相关的信息,可以在事件监听者的实现类中实现事件处理,因此事件监听对象又可以称为事件处理对象,事件源对象,事件监听对象和事件对象构成java事件处理模型的三要素,事件源对象充当观察者目标,事件监听对象充当观察者



## 22.5	观察者模式优缺点与适用环境

优点

1. 可以实现表示层和数据逻辑层得分恩利,定义了稳定的消息更新传递机制,并抽象更新接口,使得可以有各种各样不同的表示层充当具体观察者角色
2. 在观察目标和观察者之间建立一个抽象的耦合,观察目标只需要维持一个抽象观察者的集合,无须了解其他具体观察者,由于观察目标和观察者没有紧密耦合在一起,因此他们可以属于不同的抽象化层次
3. 支持广播通信,观察目标会向所有已注册的观察者对象发送通知,简化了一对多系统的设计难度
4. 符合开闭原则,增加新的具体观察者无须修改原有系统代码,在具体观察者与观察目标之间不存在关联关系的请求下增加新的观察目标也很方便

缺点

1. 如果一个观察目标对象有很多直接或间接观察者,将所有的观察者都通知到会花费很多时间
2. 如果在观察者和观察目标之间存在循环依赖,观察目标会触发他们之间进行循环调用,可能导致系统崩溃
3. 观察者模式没有相应的机制让观察者知道所观察的目标对象时怎么样发生变化的,而仅仅只知道观察目标发生了变化

适用环境

1. 一个抽象模型有两个方面,其中一个方面依赖另一个方面,将这两个方面封装在独立的对象中使他们可以各自独立的改变和复用
2. 一个对象的改变将导致一个或多个其他对象也发生变化,而并不知道具体有多少对象发生改变,也不知道这些对象是谁
3. 需要在系统中创建一个触发链,A对象的行为影响B对象,B对象的行为影响C对象.......可以使用观察者模式创建一种链式触发机制



# 第二十三章	状态模式

## 23.1状态模式概述

状态模式是一种较为复杂的设计模式,它用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题

当系统中的某个对象存在多个状态,这些状态之间可以进行转换,而且对象不同状态下行为不相同时,而可以使用状态模式实,状态模式将一个对象的状态从该对象中分离出来,封装到专门的状态类中,使得对象状态可以灵活变化



允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类



## 23.2	状态模式结构与实现

### 23.2.1	状态模式结构

1. context(环境类) 环境类又称为上下文类,它是拥有多种状态的对象,由于环境类的状态存在多样性且在不同 状态下对象的行为有所不同,因此将状态独立出去形成独立的形态类,
2. State(抽象状态类) 它用于定义一个接口以封装与环境类的一个特定状态相关的行为,在抽象状态类中声明了各种不同状态对应的方法,而在其子类中实现了这些方法,由于不同状态下的对象行为可能不同,因此在不同子类中方法的实现可能存在不同,相同的方法可以写在抽象状态类中
3. ConcreteState(具体状态类) 他是抽象状态类的子类,每一个子类实现一个与环境类的一个状态相关的行为,每一个具体状态类对应环境的一个具体状态,不同的具体状态类的行为有所不同



### 23.2.2 状态模式实现

## 23.3	共享状态



## 23.4使用环境类实现状态转换



## 23.5 状态模式优缺点与适用环境

状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中,通过设置不同的状态对象可以让环境对象拥有不同的行为,而状态转换的细节对于客户端而言是透明的, 方便了客户端的适用

优点

1. 状态模式封装了状态的转换规则,在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中,可以对状态转换代码进行集中管理,而不是分散在一个个业务方法中,
2. 状态模式将所有与某个状态有关的行为放在一个类中,只需要注入又给不同的状态对象即可使环境对象拥有不同的行为
3. 状态模式允许状态转换逻辑与状态对象合为一体,而不是提供一个巨大的条件语句,状态模式可以避免使用庞大的条件语句将业务方法和状态转换代码交织在一起
4. 状态模式可以让多个环境对象共享一个状态多项,从而减少系统中对象的个数

缺点

1. 状态模式会增加系统中类和对象的个数,导致系统运行开销增加
2. 状态模式的结构与实现都比较复杂,如果适用不当将导致程序结构和代码混乱,增加系统设计的难度
3. 状态模式对开闭原则的支持不太好,增加新的状态类需要修改那些负责状态转换的源代码,否则无法转换到新增的状态,而修改某一个状态类的行为也需要修改对应类的源代码

适用环境

1. 对象的行为依赖于它的状态,状态的改变将导致行为的变化
2. 在代码中包含大量与对象状态有关的条件语句,这些条件语句的出现会导致代码的可维护性和灵活性变差,不能方便地增加和删除状态,并且导致客户类和类库之间耦合增强





# 第二十四章	策略模式

## 24.1	策略模式概述

定义一系列算法,将每一个算法封装起来,并让他们可以相互替换,策略模式让算法独立于适用它的客户而变化



## 24.2	策略模式结构和实现

### 24.2.1	策略模式结构

1. Content(环境类) 环境类是适用算法的角色,他在解决某个问题时可以采用多种策略,在环境类中维持一个对象抽象策略类的引用实例,用于定义所采用的策略
2. Strategy(抽象策略类) 抽象策略类为所支持的算法声明了抽象方法,时所有策略类的父类,它可以是抽象类或具体类,也可以是接口,环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法
3. ConcreteStrategy(具体策略类) 具体策略类实现了在抽象策略类中声明的算法,在运行时具体策略类将覆盖在环境类中定义的抽象策略类对象,使用一种具体的算法实现某个业务功能





### 24.2.1	策略模式实现



## 24.3	策略模式优缺点与适用环境

优点

1. 提供了对开闭原则的完美支持,用户在不修改原有系统基础上选择算法和行为,也可以灵活的增加新的算法或行为
2. 提供了管理相关的算法族办法,策略类的等级结构定义了一个算法或行为族,恰当地使用继承可以把公共的代码移到抽象策略类中,从而避免代码重复
3. 策略模式提供了一种可以替换继承关系的办法,如果不使用策略模式,那么使用算法的环境类就可能会是一些子类,每一个子类提供一种不同的算法,但是这样依赖算法的使用就和算法本身混在一起,不符合单一职责原则,决定使用哪一种算法的逻辑和该该算法本身混合在一起,从而不可能再独立演化,而且使用继承无法实现算法或行为再程序运行时动态切换
4. 使用策略模式可以避免多重条件选择语句

缺点

1. 客户端必须知道所有的策略类,并自行决定使用哪一个策略,这就意味着客户端必须理解这些算法的区别,以便适时选择恰当算法,
2. 策略模式将造成系统产生很多具体的策略类,任何细小的变化都将导致系统要增加一个新的具体策略类
3. 无法同时再客户端使用多个策略,也就是说,再使用策略模式时客户端每次只能使用一个策略类,不支持使用一个策略类完成部分功能后再使用另一个策略类完成剩余功能的情况

适用环境

​	一个系统需要动态地再集中算法中选择一种,避免适用难以维护的多重条件选择语句,不希望客户端知道复杂的与算法相关的数据结构

# 第二十五章	模板方法模式

## 25.1	模板方法模式概述

模板方法模式是结构最简单的行为型设计模式,他是一种类行为模式,再其结构种只存在父类与子类之间的继承关系,通过适用模板方法模式可以将一些复杂流程的实现步骤封装再一系列基本方法中,再抽象父类中提供了一个称为模板方法的方法定义这些基本方法的执行次序,而通过其子类来覆盖某些步骤,从而使得相同的算法框架可以有不同的执行结果

定义一个操作中算法的框架,而将一些步骤延迟到子类中,模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤



## 25.2	模板方法模式结构与实现

### 25.2.1	模板方法模式结构

1. AbstractClass(抽象类) 再抽象类中定义了一系列基本操作, 这些操作可以是具体的,也可以是抽象的,每一个基本操作对应算法的一个步骤,在其子类中可以重定义或实现这些步骤,同时在抽象类中实现了一个模板方法,用于定义一个算法的框架,模板方法不仅可以调用在抽象类中实现的基本方法,也可以调用在抽象类的子类中实现的基本方法,还可以调用其他对象中的方法
2. ConcreteClass(具体子类) 它是抽象类的子类,用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤,也可以覆盖咋i父类中已经实现的具体基本操作



### 25.2.2	模板方法模式实现



### 

## 25.3	模板方法模式优缺点与适用环境

模板方法模式是基于继承的代码复用技术,它体现了面向对象的诸多重要思想,是一种适用较为频繁的设计模式,

优点

1. 在父类中形式化的定义一个算法,而由子类来实现细节的处理,在子类实现详细的处理算法时并不会改变算法中步骤的执行次序
2. 模板方法模式时一种代码复用技术,在类库设计中尤为重要,它提取了类库中的公共行为,将公共行为放在父类中,而通过其子类实现不同行为,它鼓励用户恰当地适用继承来实现代码复用
3. 模板方法模式可实现一种反向控制结构,通过子类覆盖父类的钩子方法来决定某一个特定步骤是否需要执行
4. 在模板方法模式中可以通过子类来覆盖父类的基本方法,不同的子类可以提供基本方法不同的实现,更换和增加新的子类都很方便,符合的单一职责原则和开闭原则

缺点

1. 在模板方法模式中需要为每一个基本方法的不同实现提供一个子类,如果父类中可变的基本方法太多,将会导致类的个数增加,系统更加庞大,设计也更加抽象,此时可结合桥接模式进行设计

适用环境

1. 对一些复杂的算法进行分割,将其算法中固定不变的部分设计为模板方法和父类具体方法,而一些可以改变的细节由其子类来实现,即一次性实现一个算法的不变部分,并将可变的行为留给子类来实现
2. 个子类中公共的行为应被提取出来集中到一个公共父类中以避免代码重复
3. 需要通过子类来决定父类算法中的某一个步骤是否执行,实现子类对父类的方向控制



# 第二十六章	访问者模式

## 26.1	访问者模式概述

访问者模式是一种较为复杂的行为型设计模式,它包含访问者被访问元素两个主要组成部分,这些被访问的元素具有不同的类型,且不同的访问者可以对其施加不同的访问操作,访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能,为这些不同类型的元素增加新的操作



访问者模式: 表示一个作用于某对象结构中的各个元素的操作,访问者模式让用户可以在不改变个元素的前提下定义作用于这些元素的新操作



## 26.2	访问者模式结构与实现

### 26.2.1	访问者模式结构

1. Visitor(抽象访问者) 抽象访问者为对象结构中的每一个具体元素类声明一个访问操作,从整个操作的名称或参数类型可以清楚地知道需要访问的具体元素的类型,具体访问者需要实现这些操作的方法,定义对这些元素的访问操作
2. ConcreteVisitor(具体访问者) 具体访问者实现了每一个由抽象访问者声明的操作,每一个操作用于访问对象结构中一种类型的元素
3. Element(抽象元素) 抽象元素一般是抽象类或者接口,它声明了一个accept()方法,用于接收访问者的访问操作,该方法通常以一个抽象访问者作为参数
4. ConcreteElement(具体元素)  具体元素实现了accept()方法,在方法中调用访问者的访问方法以便完成对一个元素的操作
5. ObjectStructure(对象结构) 对象结构式一个元素的集合,它用于存放元素对象,并且提供了遍历其内部元素的方法,对象结构可以结合组合模式来实现,也可以式一个简单的对象



### 26.2.2	访问者模式实现





## 26.3	访问者模式优缺点与适用环境

优点

1. 在访问者模式中增加新的访问操作很方便,使用访问者模式,增加新的访问操作意味着增加一个新的具体访问者类,实现简单,无须修改源代码,符合开闭原则
2. 访问者模式将有关元素对象的范文行为集中到一个访问者对象中,而不是分散在一个个元素中,类的职责更加清晰,有利于对象结构中元素对象的复用,相同的对象结构可以提供多个不同的访问者访问
3. 访问者模式让用户能够在不修改现有元素类层次结构的情况下定义作用于该层次结构的操作



缺点

1. 访问者模式中增加新元素类很困难,在访问者模式中,每增加一个新的元素类都意味着要在抽象访问者中增加一个新的抽象操作,并在每一个具体访问者类中增加相应的具体操作,这违背了开闭原则
2. 访问者模式破坏了对象的封装性,访问者模式要求访问对象访问并调用每一个元素对象的操作,这意味着元素对象有时候必须暴露一些自己内部操作和内部状态,否则无法供访问者访问



适用环境

1. 一个对象结构包含多个类型的对象,希望对这些对象实施一些依赖其具体类型的操作,在访问者中针对每以各种具体的类型都提供了一个访问操作,不同类型的对象可以用不同的访问操作
2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作,而需要避免让这些操作污染这些对象的类,也不希望在增加新操作式修改这些类,访问者模式使得用户可以将相关的访问操作集中起来定义在访问者类中,对象结构可以被多个不同的访问者所使用,将对象本身与对象的访问操作分离
3. 对象结构中对象对应的类很少改变,但经常需要在此对象结构上定义新的操作





